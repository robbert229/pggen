// Code generated by pggen. DO NOT EDIT.

package syntax

import (
	"context"
	"fmt"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

var _ genericConn = (*pgx.Conn)(nil)

// Querier is a typesafe Go interface backed by SQL queries.
type Querier interface {
	// Query to test escaping in generated Go.
	Backtick(ctx context.Context) (string, error)

	// Query to test escaping in generated Go.
	BacktickQuoteBacktick(ctx context.Context) (string, error)

	// Query to test escaping in generated Go.
	BacktickNewline(ctx context.Context) (string, error)

	// Query to test escaping in generated Go.
	BacktickDoubleQuote(ctx context.Context) (string, error)

	// Query to test escaping in generated Go.
	BacktickBackslashN(ctx context.Context) (string, error)

	// Illegal names.
	IllegalNameSymbols(ctx context.Context, helloWorld string) (IllegalNameSymbolsRow, error)

	// Space after pggen.arg
	SpaceAfter(ctx context.Context, space string) (string, error)

	// Enum named 123.
	BadEnumName(ctx context.Context) (UnnamedEnum123, error)

	GoKeyword(ctx context.Context, go_ string) (string, error)
}

var _ Querier = &DBQuerier{}

type DBQuerier struct {
	conn  genericConn
}

// genericConn is a connection like *pgx.Conn, pgx.Tx, or *pgxpool.Pool.
type genericConn interface {
	Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error)
	QueryRow(ctx context.Context, sql string, args ...any) pgx.Row
	Exec(ctx context.Context, sql string, arguments ...any) (pgconn.CommandTag, error)

	LoadType(ctx context.Context, typeName string) (*pgtype.Type, error)
	TypeMap() *pgtype.Map
}

// NewQuerier creates a DBQuerier that implements Querier.
func NewQuerier(ctx context.Context, conn genericConn) (*DBQuerier, error) {
	if err := register(ctx, conn); err != nil {
		return nil, fmt.Errorf("failed to create new querier: %w", err)
	}

	return &DBQuerier{
		conn: conn, 
	}, nil
}

type typeHook func(ctx context.Context, conn genericConn) error

var typeHooks []typeHook

func addHook(hook typeHook) {
	typeHooks = append(typeHooks, hook)
}

func register(ctx context.Context, conn genericConn) error {
	for _, hook := range typeHooks {
		if err := hook(ctx, conn); err != nil {
			return err
		}
	}
	
	return nil
}

// UnnamedEnum123 represents the Postgres enum "123".
type UnnamedEnum123 string

const (
	UnnamedEnum123InconvertibleEnumName UnnamedEnum123 = "inconvertible_enum_name"
	UnnamedEnum123UnnamedLabel1         UnnamedEnum123 = ""
	UnnamedEnum123UnnamedLabel2111      UnnamedEnum123 = "111"
	UnnamedEnum123UnnamedLabel3         UnnamedEnum123 = "!!"
)

func (u UnnamedEnum123) String() string { return string(u) }

const backtickSQL = "SELECT '`';"

// Backtick implements Querier.Backtick.
func (q *DBQuerier) Backtick(ctx context.Context) (string, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "Backtick")
	rows, err := q.conn.Query(ctx, backtickSQL)
	if err != nil {
		return "", fmt.Errorf("query Backtick: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (string, error) {
		var item string
		if err := row.Scan(
			&item,
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const backtickQuoteBacktickSQL = "SELECT '`\"`';"

// BacktickQuoteBacktick implements Querier.BacktickQuoteBacktick.
func (q *DBQuerier) BacktickQuoteBacktick(ctx context.Context) (string, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "BacktickQuoteBacktick")
	rows, err := q.conn.Query(ctx, backtickQuoteBacktickSQL)
	if err != nil {
		return "", fmt.Errorf("query BacktickQuoteBacktick: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (string, error) {
		var item string
		if err := row.Scan(
			&item,
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const backtickNewlineSQL = "SELECT '`\n';"

// BacktickNewline implements Querier.BacktickNewline.
func (q *DBQuerier) BacktickNewline(ctx context.Context) (string, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "BacktickNewline")
	rows, err := q.conn.Query(ctx, backtickNewlineSQL)
	if err != nil {
		return "", fmt.Errorf("query BacktickNewline: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (string, error) {
		var item string
		if err := row.Scan(
			&item,
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const backtickDoubleQuoteSQL = "SELECT '`\"';"

// BacktickDoubleQuote implements Querier.BacktickDoubleQuote.
func (q *DBQuerier) BacktickDoubleQuote(ctx context.Context) (string, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "BacktickDoubleQuote")
	rows, err := q.conn.Query(ctx, backtickDoubleQuoteSQL)
	if err != nil {
		return "", fmt.Errorf("query BacktickDoubleQuote: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (string, error) {
		var item string
		if err := row.Scan(
			&item,
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const backtickBackslashNSQL = "SELECT '`\\n';"

// BacktickBackslashN implements Querier.BacktickBackslashN.
func (q *DBQuerier) BacktickBackslashN(ctx context.Context) (string, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "BacktickBackslashN")
	rows, err := q.conn.Query(ctx, backtickBackslashNSQL)
	if err != nil {
		return "", fmt.Errorf("query BacktickBackslashN: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (string, error) {
		var item string
		if err := row.Scan(
			&item,
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const illegalNameSymbolsSQL = "SELECT '`\\n' as \"$\", $1 as \"foo.bar!@#$%&*()\"\"--+\";"

type IllegalNameSymbolsRow struct {
	UnnamedColumn0 string `json:"$"`
	FooBar         string `json:"foo.bar!@#$%&*()\"--+"`
}

// IllegalNameSymbols implements Querier.IllegalNameSymbols.
func (q *DBQuerier) IllegalNameSymbols(ctx context.Context, helloWorld string) (IllegalNameSymbolsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "IllegalNameSymbols")
	rows, err := q.conn.Query(ctx, illegalNameSymbolsSQL, helloWorld)
	if err != nil {
		return IllegalNameSymbolsRow{}, fmt.Errorf("query IllegalNameSymbols: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (IllegalNameSymbolsRow, error) {
		var item IllegalNameSymbolsRow
		if err := row.Scan(
			&item.UnnamedColumn0, // '$', 'UnnamedColumn0', 'string', '', 'string'
			&item.FooBar, // 'foo.bar!@#$%&*()"--+', 'FooBar', 'string', '', 'string'
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const spaceAfterSQL = `SELECT $1;`

// SpaceAfter implements Querier.SpaceAfter.
func (q *DBQuerier) SpaceAfter(ctx context.Context, space string) (string, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "SpaceAfter")
	rows, err := q.conn.Query(ctx, spaceAfterSQL, space)
	if err != nil {
		return "", fmt.Errorf("query SpaceAfter: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (string, error) {
		var item string
		if err := row.Scan(
			&item,
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const badEnumNameSQL = `SELECT 'inconvertible_enum_name'::"123";`

// BadEnumName implements Querier.BadEnumName.
func (q *DBQuerier) BadEnumName(ctx context.Context) (UnnamedEnum123, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "BadEnumName")
	rows, err := q.conn.Query(ctx, badEnumNameSQL)
	if err != nil {
		return UnnamedEnum123(""), fmt.Errorf("query BadEnumName: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (UnnamedEnum123, error) {
		var item UnnamedEnum123
		if err := row.Scan(
			&item,
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const goKeywordSQL = `SELECT $1::text;`

// GoKeyword implements Querier.GoKeyword.
func (q *DBQuerier) GoKeyword(ctx context.Context, go_ string) (string, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GoKeyword")
	rows, err := q.conn.Query(ctx, goKeywordSQL, go_)
	if err != nil {
		return "", fmt.Errorf("query GoKeyword: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (string, error) {
		var item string
		if err := row.Scan(
			&item,
		); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}
