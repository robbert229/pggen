// Code generated by pggen. DO NOT EDIT.

package slices

import (
	"context"
	"fmt"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
	"time"
)

var _ genericConn = (*pgx.Conn)(nil)
var _ RegisterConn = (*pgx.Conn)(nil)

// Querier is a typesafe Go interface backed by SQL queries.
type Querier interface {
	GetBools(ctx context.Context, data []bool) ([]bool, error)

	GetOneTimestamp(ctx context.Context, data *time.Time) (*time.Time, error)

	GetManyTimestamptzs(ctx context.Context, data []time.Time) ([]*time.Time, error)

	GetManyTimestamps(ctx context.Context, data []*time.Time) ([]*time.Time, error)
}

var _ Querier = &DBQuerier{}

type DBQuerier struct {
	conn  genericConn
}

// genericConn is a connection like *pgx.Conn, pgx.Tx, or *pgxpool.Pool.
type genericConn interface {
	Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error)
	QueryRow(ctx context.Context, sql string, args ...any) pgx.Row
	Exec(ctx context.Context, sql string, arguments ...any) (pgconn.CommandTag, error)
}

// NewQuerier creates a DBQuerier that implements Querier.
func NewQuerier(ctx context.Context, conn genericConn) (*DBQuerier, error) {
	return &DBQuerier{
		conn: conn, 
	}, nil
}

type typeHook func(ctx context.Context, conn RegisterConn) error

var typeHooks []typeHook

func addHook(hook typeHook) {
	typeHooks = append(typeHooks, hook)
}

type RegisterConn interface {
	LoadType(ctx context.Context, typeName string) (*pgtype.Type, error)
	TypeMap() *pgtype.Map
}

func Register(ctx context.Context, conn RegisterConn) error {
  

	for _, hook := range typeHooks {
		if err := hook(ctx, conn); err != nil {
			return err
		}
	}
	
	return nil
}





const getBoolsSQL = `SELECT $1::boolean[];`

// GetBools implements Querier.GetBools.
func (q *DBQuerier) GetBools(ctx context.Context, data []bool) ([]bool, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetBools")
	rows, err := q.conn.Query(ctx, getBoolsSQL, data)
	if err != nil {
		return nil, fmt.Errorf("query GetBools: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) ([]bool, error) {
  var item []bool
		if err := row.Scan(&item,
			); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const getOneTimestampSQL = `SELECT $1::timestamp;`

// GetOneTimestamp implements Querier.GetOneTimestamp.
func (q *DBQuerier) GetOneTimestamp(ctx context.Context, data *time.Time) (*time.Time, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetOneTimestamp")
	rows, err := q.conn.Query(ctx, getOneTimestampSQL, data)
	if err != nil {
		return nil, fmt.Errorf("query GetOneTimestamp: %w", err)
	}

	return pgx.CollectExactlyOneRow(rows, func(row pgx.CollectableRow) (*time.Time, error) {
  var item *time.Time
		if err := row.Scan(&item,
			); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const getManyTimestamptzsSQL = `SELECT *
FROM unnest($1::timestamptz[]);`

// GetManyTimestamptzs implements Querier.GetManyTimestamptzs.
func (q *DBQuerier) GetManyTimestamptzs(ctx context.Context, data []time.Time) ([]*time.Time, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetManyTimestamptzs")
	rows, err := q.conn.Query(ctx, getManyTimestamptzsSQL, data)
	if err != nil {
		return nil, fmt.Errorf("query GetManyTimestamptzs: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (*time.Time, error) {
  var item *time.Time
		if err := row.Scan(&item,
			); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}

const getManyTimestampsSQL = `SELECT *
FROM unnest($1::timestamp[]);`

// GetManyTimestamps implements Querier.GetManyTimestamps.
func (q *DBQuerier) GetManyTimestamps(ctx context.Context, data []*time.Time) ([]*time.Time, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetManyTimestamps")
	rows, err := q.conn.Query(ctx, getManyTimestampsSQL, data)
	if err != nil {
		return nil, fmt.Errorf("query GetManyTimestamps: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (*time.Time, error) {
  var item *time.Time
		if err := row.Scan(&item,
			); err != nil {
			return item, fmt.Errorf("failed to scan: %w", err)
		}
		return item, nil
	})
}
